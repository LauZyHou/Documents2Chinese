# sysmlsec_documentation

## 关于原文和本文

本文档的英文原文可在TTool官网的SysML-Sec部分找sysmlsec_documentation.pdf下载，它是关于SysML-Sec在TTool中做形式化验证的一个入门介绍。

为方便，本文中图片用 `<图x>` 标出，读者请对照原pdf来看图。

## 翻译后可能迷惑的地方

应注意区分"Safety property"和"Security property"是不同的概念，相应的"Verification"的检验目的也是不一样的，这很难在汉语中找到合宜的词与它们对应。本文档3.6节是用内置工具对攻击树模型做了Safety Verification，而文档的3.7节则是用ProVerif扩展工具对双CPU通信的架构模型做了Security Verification。

## 更多信息

译者(GitHub)：LauZyHou

辅助工具：网易有道词典

勘误者名单(GitHub)：

---

# 1 前言

## 1.1 版本表

2018年4月3号发布了最初的版本。

##  1.2 引用和可用文档表

> 译者注：无内容，略

## 1.3 缩写和术语

> 译者注：无内容，略

## 1.4 摘要

本文档用简单的例子描述如何使用SysML-Sec。特别地，它涵盖了需求、攻击树、硬件/软件划分和软件设计。

# 2 配置

## 2.1 TTool的配置

首先，如果尚未配置，则必须打开TTool的配置文件。此文件默认位于:

``` 
TTool/bin/config.xml
```

打开你的的配置文件，并根据你的TTool和ProVerif安装情况添加这几行:

* 生成安全证明的形式化的规格说明书的目录:

``` 
<ProVerifCodeDirectory data="../proverif/" />
```

* proverif的可执行文件的路径:

``` 
<ProVerifVerifierPath data="/opt/proverif/proverif" />
```

* 启动验证的主机(例如，如果你可以从特定的主机上访问"ProVerifCodeDirectory"，就可以在那台主机上启动验证):

``` 
<ProVerifVerifierHost data="localhost" />
```

## 2.2 扩展工具

DIPLODOCUS模拟工具的配置假定在你的机器上已经安装了由提供的Makefile文件引用的C编译器(缺省值为"gcc")，以及POSIX-1 librairies。此外，还必须安装Makefile实体程序(例如"GNU make")。

> 译者注：在进行Security Verification时需要ProVerif工具，可以在官网下载，并按照本文2.1节配置它的可执行文件的路径。

# 3 从一个玩具例子开始

这个最开始的例子说明了如何使用SysML-Sec的主要功能。

## 3.1 获取例子

请务必获得TTool的最新版本，包括远程加载模型(2018年3月之后的版本)的功能。点击菜单栏的"File"，选择"Open from TTool repository"，然后选择"SysMLSecTutorial.xml"。

## 3.2 理解这个模型

这个模型的第一个选项卡展示了SysML-Sec方法原理的概述(参见图1)。方法的每个阶段都用一个矩形表示，这个矩形包含到相应图表的连线。所有其它选项卡都对应于这个模型中的图表。

`<图1>` 
图1：第一个图表示SysML-Sec的方法原理。方法的每个阶段由一个矩形表示，该矩形包含到相应阶段的所有图表的连接。

## 3.3 对安全性的需求

安全需求由SysML需求图捕获，该图通过以下方式扩展:

1. 需求可以被标记为"Functional", "Non Functional", "Privacy", "Confidentiality", "Non Repudiation", "Controlled Access", "Availability", "Immunity", "Data Origin Authenticity", "Freshness", "Business", "Stakeholder Need", "Other"

2. 需求还有一个**risk**属性（低，中，高）

3. 可以添加对其他图元素的引用，并将其连接到具有"satisfy"关系的需求。"elt satifies req"意味着elt是用来满足引用需求的机制的一部分。

`图2` 
图2: 安全需求(版本#1)

## 3.4 功能模型（版本1）

这个功能模型是通过结合SysML Block Definition Diagram和SysML Internal Block Diagram来构建的，见图3。功能视图包含两个功能模块: T1和T2。T1和T2的功能行为由活动图捕获，正如图3的左侧和右侧所展示的。大体来讲，T1写入一个数据样例，T2读取一个数据样例。

`图3` 
图3：功能视图(版本#1)

正如功能模块图所展示的，T1和T2通过数据通信通道连接了起来。由于这个通信通道必须是安全的(参考图2)，现在我们可以用连接到初始需求的新的安全需求来丰富需求图(见图4)。

`图4` 
图4: 安全需求(版本#2)

我们还使用保密性来丰富T1和T2之间的通信通道comm，在comm的T1端口旁边有一个带问号的灰色锁(图3)。

## 3.5 架构和映射模型（版本1）

图5展示了一个简单的架构模型和映射关系。T1和T2分别被映射为CPU1和CPU2。T1和T2之间的通道映射为"主总线"，并连接在"主存"上。

`图5` 
图5: 映射模型(版本#1)

## 3.6 攻击树模型

我们现在可以在攻击树模型中捕获对该系统的潜在攻击。然而，SysML没有提出任何捕获错误或攻击树的途径。因此，TTool建议依赖SysML参数图来捕获攻击(或故障)。

`图6` 
图6: 攻击树模型

图6中的攻击树包含一个根攻击:“RetrieveConfidentialData”。当且仅当攻击者首先连接到总线时(让我们将此攻击称为att1)，这个根攻击才有可能发生，然后在总线上读取(并解释)数据(将此攻击称为att2)。在我们的系统中，只要确让att1和att2中的一个无法实现，就足以保证根攻击不能完成。这在我们的这棵攻击树中是显而易见的，但并不总是这么明显，例如对于具有复杂逻辑组合起来的攻击步骤的较庞大的系统而言。因此，TTool提出了一种直接从攻击树中调查给定的攻击是否有可能在系统中发起的途径。让我们一起试一试：

1. 右键根攻击，选择"Check for Reachability/Liveness"。

> 译者注：此处改正为"Check.."，原文档中为"Select.."，但软件中并没有那个选项。总之，只要将攻击树根节点上的"RL?"点出来就行。

2. 现在让我们看看是否可以访问根攻击。为此，检验图表的语法，并单击"Safety verification (internal tool)"图标。然后，选择"Reachability of selected states"，点击"start"。关闭窗口。你的图表应该被绿色的"R"标注，如图7所示。

> 译者注："检验图表的语法"在TTool软件里的操作是单击"Syntax analysis"图标，后不再重述。

3. 让我们使att1或att2不可行。为此，你可以右键单击比如att1并选择"Disable"。如果一个攻击被禁用，它可以被视为一个应对措施已经被实施。因此，countermeasure结点可以被连接到攻击结点上。在前面选择禁用att1的情形下，这个应对措施是让总线成为私有的(例如，使它集成到芯片的内部，假若攻击者无法研究芯片中的总线)。对于禁用att2而言，一个通常采用的对策是使用基于加密算法的安全协议。现在，我们采取只有att1是禁用的这种情况。再次运行验证过程。在验证完成后，你应该获得一个红色的"R"，这意味着根攻击不再可行(见图8)。

`图7` 
图7: 经过形式化验证的攻击树模型，没有禁用任何攻击步骤

`图8` 
图8: 经过形式化验证的攻击树模型，通过反措施禁用攻击步骤

## 3.7 实现安全对策

### 3.7.1 安全性验证(Security verification)

> 译者注：本节看"NonSecureFV"和"NonSecureArchitectureWithNonSecureFV"。即在不安全的架构上，使用不安全的功能模块。

在对映射模型实现安全对策之前，这里先说明一下如何实现形式化安全验证。同样，图3所示的数据通道包含一个安全属性"comm"，以核实数据通道上的信文是保密的。现在，让我们来证明一下第一个版本系统(参见图5)中的保密性：

> 译者注：此处"信文"是我对"letter"的翻译，原文中此处为"latter"，无法理顺思路，我认为是原文此处笔误。

1. 检验"NonSecureArchitectureWithNonSecureFV"这个图的语法。

> 译者注：这里读者可能会迷惑，后面的图9~图11明显是"NonSecureFV"这个tab下的模型，为什么这里又是在"NonSecureArchitectureWithNonSecureFV"上操作，因为这个"NonSecureArchitectureWithNonSecureFV"里的总线和主存都使用了"NonSecureFV"这个tab下的模型。

2. 点击"SecurityVerification (ProVerif)"图标。这将会打开一个对话框窗口，单击"start"。结果应该如图9所示。

3. 验证的结果展示在图9的下半部分。验证结果有两个：
    - 通信通道是不保密的，这证明了保密性没有被满足
    - T2和T1中的读写操作都是可达成的。在满足属性的情况下，这个结果很重要。事实上，如果无法采取这些行动，该通道将是机密的，因为该通道上不会交换数据。
4. 由于数据通道comm不是保密的，TTool可以绘制攻击轨迹，以展示攻击者是如何设法获取数据的。右键点击"Non Secure Data"，并选择"show trace"(参见图10)。这个(明显的)轨迹表明T1直接发送数据给了攻击者，因为T1将数据写入了公共总线。

5. 功能模型的视窗上可见标注了验证的结果，正如图11所示。

> 译者注：这里要回到"NonSecureFV"这个tab下的模型上去观察，读者动手试一试就能明白。

### 3.7.2 对策1：安全的总线

> 译者注：本节看"NonSecureFV"和"SecureArchitectureWithNonSecureFV"。本节的模型仍然用不安全的功能模块，但改用安全的架构。

如前所述，第一个对策是使用安全的总线，这在TTool中被描述为"private"。因此，第二个映射模型(名为"SecureArchitectureWithNonSecureFV")中的总线是"private"的。你可以在这条总线上看到绿色的盾图标。在此总线上双击一次就可以更改这个参数了("public"、"private")。

尝试进行第二个系统的安全性验证，你会观察到它的保密性被证实。

> 译者注：注意观察第一个映射模型上的验证得到的结果下面是"Non confidential Data"，而第二个(带绿盾)的映射模型上的验证的到的结果下面是"Confidential Data"，所以在这里右键发现点不了"show trace"。

### 3.7.3 对策2：安全的功能

> 译者注：本节看"SecureFV"和"NonSecureArchitectureWithSecureFV"。本节的模型换上了安全的功能模块，但仍使用不安全的架构。

第二个对策在于在两个功能T1和T2之间添加安全机制。TTool提供加密配置，以向功能模块添加安全机制(见我们的Modelsward 2017论文)。基本上，一个加密配置
指定了安全机制的类型(对称密码、散列、密钥操作、nonce等)及其(基于样例的复杂操作)对性能的影响。

修改后的T1和T2活动图如图13所示。请注意，只有活动图相对于以前的版本进行了修改。

> 译者注：观察TTool软件在这个模型下最里层的一排tab可以看到有一个总的组件任务图，组织了T1和T2等的架构关系，还有T1和T2各自的活动图。

如果双击T1的SE操作符，将会呼出下面的窗口(参见图14)。此对话框中包含以下字段：

> 译者注：这里是双击"SecureFV"下的T1的活动图上的SE操作符。

`图9` 
图9: 做Security Verification的对话框

`图10` 
图10: 攻击轨迹

`图11` 
图11: 带有Security Verification注解的功能模型

`图12` 
图12: "private"总线的安全架构

`图13` 
图13: 使用加密配置改进的功能模块

* 配置的**名称**。当写数据或者读数据时，这个名称对于引述指定的加密配置是很有用的。例如，T1向数据通道comm上写数据使用了名为Cipherdat的加密配置。

* 加密的**类型**: 对称、非对称、MAC、散列、Nonce、Advanced。在我们的示例中，选择了对称加密的方式。

* 所选操作的整数运算**复杂度**。

* 加密材料的使用：密钥、nonces和精确算法(AES等)。

可以在Security选项卡上为数据通道标记上所使用的加密配置，它的可选项如图15所示。默认情况下，使用加密配置标记的通道将以加密的形式来发送数据。但是，随着(接下来要说的)硬件安全模块(HSM)的投入使用，将未加密的数据发送到HSM加密可能会成为必要的，这样一来选项中的"Encrypted form"(加密的形式)需要标记为"No"。此外，如果任务是一个攻击者任务(参见我们在Modelsward 2018中的论文)，也可以将数据通道标记为"attacker channels"。如果通道以未加密的形式发送要保护的数据，则在活动上，加密配置的名称将以红色显示。

> 译者注：这里是双击"SecureFV"下的T1的活动图上的数据通道comm。

现在让我们看看第三个映射模型(名为"NonSecureArchitectureWithSecureFV")它主要意在将安全任务映射到不安全的架构上(即有"public"总线的那个)。该系统的Security Verification结果如图16所示。现在验证了保密性。

`图16` 
图16: 具有安全功能的非安全体系结构的验证结果

不幸的是，安全机制会影响系统的性能。TTool可以评估两种不同映射的性能，比如没有安全机制的版本1和有安全机制的版本3。如需做这样的事，TTool需要依赖DIPLODOCUS模拟器。

不考虑硬件平台的account penalties(比如cache未命中，任务切换时间，启动时间等)，仿真在非安全的系统上花费20个周期(见图17)，而在添加了安全机制的任务上花费了220个周期(20周期+100周期加密+100周期破译密码)(参见图18)。

> 译者注：account penalties不知道该怎么翻译，这里我的理解是不考虑硬件平台本身对时间的影响。

`图17` 
图17: 映射在非安全架构上的非安全应用程序的仿真

`图18` 
图18: 映射在非安全架构上的安全应用程序的仿真(仅部分)

## 3.8 自动生成安全

给定对安全性的需求以及不安全的模型，我们的工具包就会神奇地添加安全元素。它可以(1)将安全操作符添加到功能模块中，可以选择添加一个执行所有安全操作的HSM，(2)自动、安全地映射密钥。有关如何增加安全性的详细算法，请参阅 Letitia Li的论文"Safe and Secure Model-Driven Design for Embedded Systems"。

首先，每个security-critical的数据通道，都应该标记为"不论是否有数据通过，都要检查其保密性或真实性"。假设要检查的安全性属性是应该为每个数据通道所确保的属性。

### 3.8.1 添加安全操作符

当选上"add security operators"选项时，有多个可添加的安全操作符类型的选项。用户应该选择模型是否应该保证保密性、弱真实性和(或)强真实性。例如，如果用户只希望添加操作符以确保confidentiality(保密性)，那么工具箱将忽略对authenticity(真实性)的要求，而只将加密操作符添加到标有安全注释的数据通道中，该注释指示通道的数据必须是保密的。

> 译者注：保密性confidentiality、弱真实性weak authenticity、强真实性strong authenticity。

此外，对于要添加的操作符，可以手动设置执行加密、解密、计算MAC等操作的预估时间和开销，以代替默认选项来使用。

例如，使用图3和图5中不安全的架构和功能模型，如果通信通道被标记为应该是authentic(真实)的，并且我们选择只确保weak authenticity(弱真实性)，那么工具箱将生成图20中所示的功能模型。连接到消息上的消息身份验证代码只能用给定的密钥和消息计算，如果T2检测到它们不匹配，那么它将丢弃消息，因为这不是T1发送的真实消息。

如果我们选择添加weak and strong authenticity(弱真实性和强真实性)，则任务应该交换一个nonce以避免replay attacks(重播攻击)，并生成图21中的功能模型。

`图19` 
图19: 自动生成Security的窗口

`图20` 
图20: 带有自动生成的安全操作符的功能模块，以确保weak authenticity(弱真实性)

`图21` 
图21: 带有自动生成的安全操作符的功能模块，以确保strong authenticity(强真实性)

### 3.8.2 添加硬件安全模块(HSM)

对于自动安全生成，还可以选择添加若干HSM来替代执行所有的安全操作。我们的工具包可以自动将若干HSM添加到指定的任务中，对与向HSM发送数据的相关的图进行全部的修改，生成HSM的活动图，等等。每个至少执行一个指定任务的处理器都会被添加一个硬件安全模块。如果为映射到单个CPU的多个任务添加HSM，则只会添加一个HSM。

对于每个要执行安全操作而添加的HSM(可以是用于一个或多个任务)而言，首先，架构图会被修改为添加一个硬件加速器和内存，并使用一个"private"的总线相连接。

接下来，每个任务都会被修改，以使得在每个发送信息的实例之前都应该是安全的，任务首先会发出带有数据通道的索引的请求(在需使多个通道安全的情形下)，并将数据发送给HSM。接下来HSM会执行安全操作，并将安全的信息返回给(刚刚的那个)任务，然后(刚刚的那个)任务再将此安全的(不妨理解成"加密后的")信息发送给接收任务。当任务接收到要解密的数据时，它也会同样地将信息发送给HSM, HSM随后对其进行解密并将解密后的信息返回给这个任务，以及接收任务该如何理解这条信息的内容。

> 译者注：在这个过程中，HSM就充当了一个中央的加密、解密器的作用，并且认定HSM和各个task之间的信息交换都是绝对安全的，所以发送者将信息发送给HSM，HSM加密并将其返回，发送者再将这条加密后的信息发给接收者，接受者拿到加密后的信息再发送给HSM，HSM将其解密后返回给接受者。

例如，使用我们的示例中的模型，选择确保confidentiality(保密性)，并为每个任务添加HSM。在图22的功能模型中为每个HSM添加了一个新的HSM任务。在图23所示的架构/映射模型中为每个CPU添加了一个安全总线、内存和硬件加速器。图24则显示了任务t1以及HSM的活动图是如何被修改的，以将数据信息发送到HSM进行加密。

`图22` 
图22: 添加了硬件安全模块任务的功能模型

`图23` 
图23: 添加了硬件安全模块任务的架构模型

`图24` 
图24: 修改T1和HSM的活动图

### 3.8.3 密钥的映射

因为存在多种加密配置，所以将所有密钥映射到内存可能非常麻烦。基于此，我们的工具包可以找到某一任务所使用的每个加密配置，然后根据加密配置的类型，将每个适用的密钥映射到任务可以安全访问的内存中去。对于对称加密或MAC类型的加密配置，发送任务和接收任务都要能够访问密钥。然而，对于非对称加密，所有的发送任务都需要公钥，而只有接收任务才需要能访问私钥。

每次做安全生成，密钥都会自动生成并安全地映射。也可以选择在手动完成设计后单独添加密钥。

如果密钥是沿着攻击者可以访问的总线发送的，那么攻击者就能获取密钥，所以我们希望避免沿着"public"总线发送密钥。对于每个需要密钥的任务，算法将会搜索映射到其(指任务)上的处理器的安全可访问的内存。该算法使用广度优先搜索遍历所有可能的"private"总线和桥，直到找到一个内存为止。接下来，密钥会被映射到该内存。如果搜索了所有可能的安全路径，但没有找到内存，则会发出警告，表明无法为该任务分配密钥。

举例来说，对于图20中的自动安全模型，autoEncrypt_comm的密钥映射如图25所示，其中有一个到内存的安全路径。如果密钥被映射到主内存，那么攻击者就可以在"public"的主总线上读数据时获取密钥。

`图25` 
图25: 有映射密钥的映射模型

## 3.9 设计安全协议

在硬件/软件划分的阶段，安全机制已经在高抽象级别上建模，主要是为了将它们正确地放置在系统中，并评估它们对系统性能的影响。在软件设计阶段，可以更精确地设计安全协议。

软件设计包含一个框图(见图26)以及每个任务块的状态机(见图27)。

框图包含一个主块("System")和其中的两个子块("T1"和"T2")。这些任务对应于在更高抽象级别的硬件/软件划分阶段中建模的相同任务。另外两个块"Key"和"Messages"是定义的自定义数据类型。T1和T2是加密块，即它们定义默认的加密方法，如加密、解密、哈希、mac、信息操作(concat、cut)等。最后，一些杂注:

* 连接T1和T2的加密密钥。这个密钥"sk"是全系统的，这意味着它在所有协议会话中共享一次。

* 给出要检查的安全属性："T1"的"secretData"字段的值必须保密。

`图26` 
图26: 安全协议的设计

`图27` 
图27: T1(左边)和T2(右边)的状态机

安全形式验证可以从这些图中执行。就像硬件/软件划分模型一样，可以研究安全属性和状态的可达性，当属性满足时，结果可以回显到图中，例如绿色锁(参见图28)。

`图28` 
图28: Security Verification的结果

